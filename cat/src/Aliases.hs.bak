-- This module handles matching names with aliases.
-- For instance Plus and Add are aliases and so matching PlusExp with AddExp
-- should cost nothing.
module Aliases (Word, Aliases, matchNameWithAliases) where

import Prelude hiding (Word)
import Data.List ((\\), find, sortBy, minimum, minimumBy)
import Data.Char (toLower, toUpper, isLower, isUpper)
import Data.Maybe (catMaybes, listToMaybe)
import Debug.Trace (trace)

type Word = String
type Aliases = [Word]

applyAliases :: [Aliases] -> [Word] -> [[Word]]
applyAliases aliasess words = expandAliases $ rewrite aliasess words
  where
    rewrite :: [Aliases] -> [Word] -> [Aliases]

    rewrite [] words = map return words
    rewrite (aliases:moreAliases) words = applied
      where
        appliedTail = rewrite moreAliases words
        applied = map
          (\aliasesForWord -> concatMap (rewriteWord aliases) aliasesForWord)
          appliedTail

    rewriteWord :: Aliases -> Word -> [Word]
    rewriteWord aliases word = if word `elem` aliases then aliases else [word]

    expandAliases :: [Aliases] -> [[Word]]
    expandAliases [] = []
    expandAliases [ys] = do
      y <- ys
      return [y]
    expandAliases (ys:yss) = do
      y <- ys
      zs <- expandAliases yss
      return (y:zs)

-- NOT USED
matchName :: [Aliases] -> String -> String -> Int
matchName aliases x y = trace debugString mincost
  where
    xs = breakNameIntoWords x
    ys = breakNameIntoWords y
    xss = applyAliases aliases xs
    yss = applyAliases aliases ys
    (minx, miny, mincost) =
      minimumBy (\(_, _, c1) (_, _, c2) -> c1 `compare` c2)
        [(xs, ys, editDistanceStrings xs ys) | xs <- xss, ys <- yss]
    debugString = "matchName " ++ x ++ " " ++ y ++ " -> " ++
                       (show minx) ++ " " ++ (show miny)

-- Break a name like PlusExp or Plus_Exp into words: [Plus, Exp]
breakNameIntoWords "" = []
-- under_score
breakNameIntoWords ('_':xs) = "" : breakNameIntoWords (dropWhile (=='_') xs)
-- CamelCase
breakNameIntoWords (x:y:ys)
  | isLower x && isUpper y = (x:"") : breakNameIntoWords (y:ys)
--
breakNameIntoWords (x:xs) = case words of
    [] -> [x:""]
    (w:ws) -> (x:w):ws
  where
    words = breakNameIntoWords xs

matchNameWithAliases :: [[String]] -> String -> String -> Int
matchNameWithAliases aliases x y =
    {-
    trace ("matchNameWithAliases " ++ x ++ " ~~ " ++ y ++ ": " ++ show r) $
      trace ("  aliases for " ++ (show ys) ++ " ===> " ++ (show as)) r
      -}
    r
  where
    r = minimum $ map (editDistanceStrings xs) as
    as = applyAliases aliases ys
    xs = breakNameIntoWords (map toLower x)
    ys = breakNameIntoWords (map toLower y)

editDistanceString = editDistance (const 1) (const (const 10))
editDistanceStrings = editDistance length editDistanceString

editDistance :: Eq a => (a -> Int) -> (a -> a -> Int) -> [a] -> [a] -> Int
editDistance cost cost2 [] [] = 0
editDistance cost cost2 (x:xs) [] = sum (map cost (x:xs))
editDistance cost cost2 [] (x:xs) = sum (map cost (x:xs))
editDistance cost cost2 (x:xs) (y:ys)
  | x == y    = editDistance cost cost2 xs ys
  | otherwise = minimum [
      (cost x) + (editDistance cost cost2 xs (y:ys)),
      (cost y) + (editDistance cost cost2 (x:xs) ys),
      (cost2 x y) + (editDistance cost cost2 xs ys)
    ]
